{
  "hash": "89449d7d6b2356fe13c2b0b332f679c4",
  "result": {
    "markdown": "---\ntitle: \"Mini-Project 3: Confidence Intervals Simulation Study\"\nauthor: \"Tanner Bessette\"\ndate: \"03-05-2025\"\nformat: pdf\n---\n\n\nI have followed all rules for collaboration for this project, and I have not used generative AI on this project. Tanner Bessette\n\n## Step 1\n\n3 different sample sizes:\n\nsmall: n = 5\n\nmedium: n = 40\n\nlarge: n = 1000\n\n2 different values for p:\n\np = 0.5 and p = 0.1\n\n## Steps 2,3,4\n\n## Large n (n = 1000) and p = 0.5\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n-- Attaching core tidyverse packages ------------------------ tidyverse 2.0.0 --\nv dplyr     1.1.4     v readr     2.1.5\nv forcats   1.0.0     v stringr   1.5.1\nv ggplot2   3.5.1     v tibble    3.2.1\nv lubridate 1.9.3     v tidyr     1.3.1\nv purrr     1.0.2     \n-- Conflicts ------------------------------------------ tidyverse_conflicts() --\nx dplyr::filter() masks stats::filter()\nx dplyr::lag()    masks stats::lag()\ni Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n:::\n\n```{.r .cell-code}\nn <- 1000\np <- 0.5\n\ngenerate_samp_prop <- function(n, p) {\n  x <- rbinom(1,n,p)\n  \n  # number of successes divided by sample size\n  phat <- x / n\n  \n  # we have to use 1.645 instead of 1.96 bc 90% confidence\n  lb <- phat - 1.645 * sqrt(phat * (1 - phat) / n)\n  ub <- phat + 1.645 * sqrt(phat * (1 - phat) / n)\n  \n  prop_df <- tibble(phat, lb, ub)\n  return(prop_df)\n}\n\n# run the function with our assigned n and p values\ngenerate_samp_prop(n = 1000, p = 0.5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 x 3\n   phat    lb    ub\n  <dbl> <dbl> <dbl>\n1 0.521 0.495 0.547\n```\n:::\n\n```{.r .cell-code}\n# we want 5000 ci's\nn_sim = 5000\n\nprop_ci_df <- map(1:n_sim,\n    \\(i) generate_samp_prop(n = 1000, p = 0.5)) |>\n  bind_rows()\n\nprop_ci_df\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5,000 x 3\n    phat    lb    ub\n   <dbl> <dbl> <dbl>\n 1 0.513 0.487 0.539\n 2 0.492 0.466 0.518\n 3 0.496 0.470 0.522\n 4 0.524 0.498 0.550\n 5 0.524 0.498 0.550\n 6 0.511 0.485 0.537\n 7 0.511 0.485 0.537\n 8 0.488 0.462 0.514\n 9 0.5   0.474 0.526\n10 0.499 0.473 0.525\n# i 4,990 more rows\n```\n:::\n\n```{.r .cell-code}\nprop_ci_df <- prop_ci_df |> mutate(ci_width = ub - lb,\n             ci_cover_ind = if_else(p > lb & p < ub,\n                                             true = 1, \n                                             false = 0))\n\n# output the average interval widths and the coverage rates\nprop_ci_df |> summarise(avg_width = mean(ci_width),\n                        coverage_rate = mean(ci_cover_ind))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 x 2\n  avg_width coverage_rate\n      <dbl>         <dbl>\n1    0.0520         0.901\n```\n:::\n:::\n\n\nFor n = 1000 and p = 0.5, we have an average interval width of 0.0520, and a coverage rate of 89.5%.\n\n## Large n (n = 1000) and p = 0.1\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- 1000\np <- 0.1\n\n# run the function with our assigned n and p values\ngenerate_samp_prop(n = 1000, p = 0.1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 x 3\n   phat     lb    ub\n  <dbl>  <dbl> <dbl>\n1 0.095 0.0797 0.110\n```\n:::\n\n```{.r .cell-code}\n# we want 5000 ci's\nn_sim = 5000\n\nprop_ci_df <- map(1:n_sim,\n    \\(i) generate_samp_prop(n = 1000, p = 0.1)) |>\n  bind_rows()\n\nprop_ci_df\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5,000 x 3\n    phat     lb    ub\n   <dbl>  <dbl> <dbl>\n 1 0.103 0.0872 0.119\n 2 0.087 0.0723 0.102\n 3 0.111 0.0947 0.127\n 4 0.095 0.0797 0.110\n 5 0.09  0.0751 0.105\n 6 0.101 0.0853 0.117\n 7 0.107 0.0909 0.123\n 8 0.101 0.0853 0.117\n 9 0.095 0.0797 0.110\n10 0.111 0.0947 0.127\n# i 4,990 more rows\n```\n:::\n\n```{.r .cell-code}\nprop_ci_df <- prop_ci_df |> mutate(ci_width = ub - lb,\n             ci_cover_ind = if_else(p > lb & p < ub,\n                                             true = 1, \n                                             false = 0))\n\n# output the average interval widths and the coverage rates\nprop_ci_df |> summarise(avg_width = mean(ci_width),\n                        coverage_rate = mean(ci_cover_ind))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 x 2\n  avg_width coverage_rate\n      <dbl>         <dbl>\n1    0.0311         0.897\n```\n:::\n:::\n\n\nFor n = 1000 and p = 0.1, we have an average interval width of 0.0312, and a coverage rate of exactly 90%.\n\n## Medium n (n = 40) and p = 0.5\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- 40\np <- 0.5\n\n# run the function with our assigned n and p values\ngenerate_samp_prop(n = 40, p = 0.5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 x 3\n   phat    lb    ub\n  <dbl> <dbl> <dbl>\n1 0.525 0.395 0.655\n```\n:::\n\n```{.r .cell-code}\n# we want 5000 ci's\nn_sim = 5000\n\nprop_ci_df <- map(1:n_sim,\n    \\(i) generate_samp_prop(n = 40, p = 0.5)) |>\n  bind_rows()\n\nprop_ci_df\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5,000 x 3\n    phat    lb    ub\n   <dbl> <dbl> <dbl>\n 1 0.475 0.345 0.605\n 2 0.525 0.395 0.655\n 3 0.45  0.321 0.579\n 4 0.525 0.395 0.655\n 5 0.5   0.370 0.630\n 6 0.425 0.296 0.554\n 7 0.475 0.345 0.605\n 8 0.5   0.370 0.630\n 9 0.475 0.345 0.605\n10 0.4   0.273 0.527\n# i 4,990 more rows\n```\n:::\n\n```{.r .cell-code}\nprop_ci_df <- prop_ci_df |> mutate(ci_width = ub - lb,\n             ci_cover_ind = if_else(p > lb & p < ub,\n                                             true = 1, \n                                             false = 0))\n\n# output the average interval widths and the coverage rates\nprop_ci_df |> summarise(avg_width = mean(ci_width),\n                        coverage_rate = mean(ci_cover_ind))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 x 2\n  avg_width coverage_rate\n      <dbl>         <dbl>\n1     0.257         0.914\n```\n:::\n:::\n\n\nFor n = 40 and p = 0.5, we have an average interval width of 0.257, and a coverage rate of 91.7%.\n\n## Medium n (n = 40) and p = 0.1\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- 40\np <- 0.1\n\n# run the function with our assigned n and p values\ngenerate_samp_prop(n = 40, p = 0.1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 x 3\n   phat       lb    ub\n  <dbl>    <dbl> <dbl>\n1  0.05 -0.00669 0.107\n```\n:::\n\n```{.r .cell-code}\n# we want 5000 ci's\nn_sim = 5000\n\nprop_ci_df <- map(1:n_sim,\n    \\(i) generate_samp_prop(n = 40, p = 0.1)) |>\n  bind_rows()\n\nprop_ci_df\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5,000 x 3\n    phat       lb    ub\n   <dbl>    <dbl> <dbl>\n 1 0.075  0.00649 0.144\n 2 0.125  0.0390  0.211\n 3 0.1    0.0220  0.178\n 4 0.1    0.0220  0.178\n 5 0.15   0.0571  0.243\n 6 0.05  -0.00669 0.107\n 7 0.075  0.00649 0.144\n 8 0      0       0    \n 9 0.2    0.0960  0.304\n10 0.05  -0.00669 0.107\n# i 4,990 more rows\n```\n:::\n\n```{.r .cell-code}\nprop_ci_df <- prop_ci_df |> mutate(ci_width = ub - lb,\n             ci_cover_ind = if_else(p > lb & p < ub,\n                                             true = 1, \n                                             false = 0))\n\n# output the average interval widths and the coverage rates\nprop_ci_df |> summarise(avg_width = mean(ci_width),\n                        coverage_rate = mean(ci_cover_ind))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 x 2\n  avg_width coverage_rate\n      <dbl>         <dbl>\n1     0.149         0.901\n```\n:::\n:::\n\n\nFor n = 40 and p = 0.1, we have an average interval width of 0.150, and a coverage rate of 90.6%.\n\n## Small n (n = 5) and p = 0.5\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- 5\np <- 0.5\n\n# run the function with our assigned n and p values\ngenerate_samp_prop(n = 5, p = 0.5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 x 3\n   phat    lb    ub\n  <dbl> <dbl> <dbl>\n1   0.6 0.240 0.960\n```\n:::\n\n```{.r .cell-code}\n# we want 5000 ci's\nn_sim = 5000\n\nprop_ci_df <- map(1:n_sim,\n    \\(i) generate_samp_prop(n = 5, p = 0.5)) |>\n  bind_rows()\n\nprop_ci_df\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5,000 x 3\n    phat     lb    ub\n   <dbl>  <dbl> <dbl>\n 1   0.6 0.240  0.960\n 2   0.4 0.0396 0.760\n 3   0.4 0.0396 0.760\n 4   0.4 0.0396 0.760\n 5   0.4 0.0396 0.760\n 6   0.4 0.0396 0.760\n 7   0.6 0.240  0.960\n 8   0.6 0.240  0.960\n 9   0.4 0.0396 0.760\n10   0.4 0.0396 0.760\n# i 4,990 more rows\n```\n:::\n\n```{.r .cell-code}\nprop_ci_df <- prop_ci_df |> mutate(ci_width = ub - lb,\n             ci_cover_ind = if_else(p > lb & p < ub,\n                                             true = 1, \n                                             false = 0))\n\n# output the average interval widths and the coverage rates\nprop_ci_df |> summarise(avg_width = mean(ci_width),\n                        coverage_rate = mean(ci_cover_ind))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 x 2\n  avg_width coverage_rate\n      <dbl>         <dbl>\n1     0.631         0.617\n```\n:::\n:::\n\n\nFor n = 5 and p = 0.5, we have an average interval width of 0.634, and a coverage rate of 62.6%.\n\n## Small n (n = 5) and p = 0.1\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- 5\np <- 0.1\n\n# run the function with our assigned n and p values\ngenerate_samp_prop(n = 5, p = 0.1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 x 3\n   phat    lb    ub\n  <dbl> <dbl> <dbl>\n1     0     0     0\n```\n:::\n\n```{.r .cell-code}\n# we want 5000 ci's\nn_sim = 5000\n\nprop_ci_df <- map(1:n_sim,\n    \\(i) generate_samp_prop(n = 5, p = 0.1)) |>\n  bind_rows()\n\nprop_ci_df\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5,000 x 3\n    phat      lb    ub\n   <dbl>   <dbl> <dbl>\n 1   0.2 -0.0943 0.494\n 2   0.2 -0.0943 0.494\n 3   0    0      0    \n 4   0    0      0    \n 5   0    0      0    \n 6   0.2 -0.0943 0.494\n 7   0.2 -0.0943 0.494\n 8   0    0      0    \n 9   0    0      0    \n10   0    0      0    \n# i 4,990 more rows\n```\n:::\n\n```{.r .cell-code}\nprop_ci_df <- prop_ci_df |> mutate(ci_width = ub - lb,\n             ci_cover_ind = if_else(p > lb & p < ub,\n                                             true = 1, \n                                             false = 0))\n\n# output the average interval widths and the coverage rates\nprop_ci_df |> summarise(avg_width = mean(ci_width),\n                        coverage_rate = mean(ci_cover_ind))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 x 2\n  avg_width coverage_rate\n      <dbl>         <dbl>\n1     0.249         0.398\n```\n:::\n:::\n\n\nFor n = 5 and p = 0.1, we have an average interval width of 0.253, and a coverage rate of 40.1%.\n\n## Table\n\n|           |               | $n = 5$ | $n = 40$ | $n=1000$ |\n|:---------:|:-------------:|:-------:|:--------:|:--------:|\n| $p = 0.5$ | Coverage Rate |  62.6%  |  91.7%   |  89.5%   |\n| $p = 0.1$ | Coverage Rate |  40.1%  |  90.6%   |   90%    |\n|           |               |         |          |          |\n| $p = 0.5$ | Average Width |  0.634  |  0.253   |  0.052   |\n| $p = 0.1$ | Average Width |  0.253  |  0.150   |  0.0312  |\n\n: Table of Results {.striped .hover}\n\n## Large Sample Assumption Calculations\n\nCheck that:\n\n$n$ \\* $\\hat{p}$ \\> 10 and $n$ \\* $(1 - \\hat{p})$ \\> 10\n\nare both satisfied for the large sample assumption to hold.\n\n**Setting 1: Large n (n = 1000) and p = 0.5**\n\n1000 \\* 0.5 \\> 10 and 1000 \\* (1 - 0.5) \\> 10 both true\n\nSo, the large sample assumption holds.\n\n**Setting 2: Large n (n = 1000) and p = 0.1**\n\n1000 \\* 0.1 \\> 10 and 1000 \\* (1 - 0.1) \\> 10 both true\n\nSo, the large sample assumption holds.\n\n**Setting 3: Medium n (n = 40) and p = 0.5**\n\n40 \\* 0.5 = 20 \\> 10 and 40 \\* (1 - 0.5) = 20 \\> 10 both true\n\nSo, the large sample assumption holds.\n\n**Setting 4: Medium n (n = 40) and p = 0.1**\n\n40 \\* 0.1 = 4 \\< 10\n\nSo, the large sample assumption does not hold.\n\n**Setting 5: Small n (n = 5) and p = 0.5**\n\n5 \\* 0.5 = 2.5 \\< 10\n\nSo, the large sample assumption does not hold.\n\n**Setting 6: Small n (n = 5) and p = 0.1**\n\n5 \\* 0.1 = 0.5 \\< 10\n\nSo, the large sample assumption does not hold.\n\n## Mini-Project Summary\n\nGenerally, the bigger the sample size n, the smaller the average width. The smaller the sample size, the larger the average width, especially with our extremely low sample size (n = 5), where we had average widths of 0.634 (p = 0.5) and 0.253 (p = 0.1)! For all of the different n's, the simulations yielded a larger average width for p = 0.5 than for p = 0.1 (about twice as large of a width for p = 0.5 than p = 0.1).\n\nFrom our large sample assumption calculations, the settings that have sufficiently large n are *n = 1000 and p = 0.5*, *n = 1000 and p = 0.1*, and *n = 40 and p = 0.5*. For these settings, we are able to interpret: \"We are 90% confident that the true population proportion p is contained within our confidence intervals.\" The settings that do not have sufficiently large n are *n = 40 and p = 0.1*, *n = 5 and p = 0.5*, and *n = 5 and p = 0.1*. In these settings, we do not have a large enough n to trust the confidence interval to be reliable.\n\nWith n = 1000 and n = 40 the coverage rates are extremely close to 90%, which is our confidence interval. For n = 1000 and p = 0.5, the coverage rate is likely only 89.5% (and not 90%) due to random variation. When the n is too small, i.e. n = 5, the coverage rate also goes way down (far below 90% coverage). This is likely in part due to the fact that these two settings weren't even close to satisfying the large sample assumption.\n\nThe overall takeaway is that if we get a large enough n, we can have a coverage rate very close, if not exactly equal to, our confidence level, and the average width will be smaller with higher n. With a smaller n, we lose some of the accuracy in coverage rate, and the interval widths grow larger.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}